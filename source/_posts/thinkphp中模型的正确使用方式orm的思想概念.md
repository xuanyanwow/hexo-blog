---
title: 'Thinkphp中模型的正确使用方式,ORM的思想概念'
tags:
  - PHP
  - Thinkphp
  - 计算机基础
id: '80'
categories:
  - - PHP
date: 2019-07-13 20:02:58
---

在Thinkphp的文档中关于框架特性的描述，有这么一句话

> ORM：重构的数据库、模型及关联，MongoDb支持；

从这句话可以得知，Thinkphp中的数据库、模型，基于的ORM概念来完成。

## ORM是什么？

对象-关系映射（OBJECT-RELATIONAL MAPPING，简称ORM） 这是在`面向对象`编程发展过程中演变出来的一种思想、行为概念。 主要用途是：`把对象模型表示的对象映射到基于sql的关系模型数据库结构中去。` 当改变这个对象自身的属性或者调用该对象的方法时，相对应的是执行某些sql语句。 这样子编写代码的人员就可以更好地编写业务逻辑，而非重复地编写增删改查sql语句。

## thinkphp中的运用示例

TP框架中关于数据库操作有两个模块：

*   数据库
*   模型

### tp中的数据库模块

引用一句文档的特性描述

> 拆分为Connection（连接器）/Query（查询器）/Builder（SQL生成器）

*   Connection连接器主要是用来连接数据库的，可以使用不同的驱动连接不同类型的数据库。
*   Query查询器则是用来运行sql语句，处理结果，映射到`数据集`中。
*   Builder生成器则是用来把我们传递进去的条件、排序等转换成sql语句。

在这3个步骤中，我们可以知道，如果有运用到ORM思想抽象映射的，那就只可能是Query查询器模块，但是我们可以细查`TP文档中关于数据集的描述`。 它更多的是封装提供对于数据的处理方法，比如： (以下是从文档复制过来的 一小部分)

```
toArray     将数据集的数据转为数组
merge   合并其它数据
diff    比较数组，返回差集
flip    交换数据中的键和值
intersect   比较数组，返回交集
keys    返回数据中的所有键名
pop 删除数据中的最后一个元素
shift   删除数据中的第一个元素
unshift 在数据开头插入一个元素
reduce  通过使用用户自定义函数，以字符串返回数组
```

但是却没有提供反向映射的关系操作，比如我们操作数据集，自动更新数据库中的数据。 所以在我的理解中，`数据库模块`中的ORM思想并不多，重点还是要了解和运用`模型`

### tp中的模型

##### **定义模型文件**

```php
namespace app\index\model;

use think\Model;

// 设置类名 需要遵循转换规则，蛇形转为大驼峰
class User extends Model
{
    // 设置主键字段名
    protected $pk = 'u_id';

    // 开启自动维护时间戳字段 (什么时间插入 什么时间更新)
    protected $autoWriteTimestamp = true;

    // 软删除 开启之后 删除数据只是用一个字段来标识为删除状态 方便查询、备份等
    use SoftDelete;
    protected $deleteTime = 'delete_time';

}
```

以上代码比文档中第一章节`模型初始化`要多了一些内容，这是为了突出 `模型可以完成很多功能` 这也是ORM出现的原因：将sql的执行，抽象映射为面向对象编程中的对象。 我们可以理解为：表中的一行数据，代表我们代码中new一个对象，改变对象，则自动更新表中对应的行。

##### **使用模型**

演示的代码是比较简单的，实际是可以很灵活的 比如查询用非主键的条件来查询、查询多行记录等等

```php
<?php
// *******快速查询、更新*******
// 查询主键=1的数据
$user = User::get(1);
// 然后更改它的name字段为新的值
$user->name = 'thinkphp';
// 保存，自己去数据库给我更新吧~
$user->save();

// *******插入新的一行数据*******
// 新建一个对象(相对应的操作就是新创建一行)
$user = new User;
// 设置字段的值  有多个字段就多个设置
$user->name= 'thinkphp';
// 保存，自己去插入吧~
$user->save();
```

##### **误区**

看了使用之后，很多初学者就开始写代码了，然而却使用了不太正确的方式。 ① model只当为Db类用 虽然model可以看成db类的超集，但是如果只是把它当成简单的DB类使用，而不是`使用ORM思想去编写`。那么就没什么必要使用它了。。 如果使用不对，不仅不能提高效率，反而会影响自己。（比如代码规范不统一、新增表还要新增对应的模型文件等等） 代码演示：

```php
<?php
$userModel = new User(); // 这里就相当于初始化Db类
$userOneInfo = $userModel->where(['u_id' => 1])->find();

$userTwoInfo = $userModel->where(['u_id' => 2])->find();
// ... 执行其他逻辑 比如判断上下级 操作权限等等

// 业务需求不只是读取用户的数据这么简单
// 还要扣除余额(就是更新数据库)
$userOneRes = $userModel->where(['u_id' => 1])->update(['u_balance' => 'xxxx']);

// ... 执行其他逻辑 
```

看到这里，先停下来思考一下。。你的代码有出现过这样子的吗？ 我相信还是有些人会这样子用的吧！因为我以前也是这样子用的。 那么我们看看正确的使用方法(我认为的，如果觉得不对或者有更好的，欢迎评论交流)

```php
<?php

$userOneInfo = User::get(1);

// 这里演示使用非主键条件查询的情况！！
// 查询一个1用户的下级出来
$userTwoInfo = User::get(function($query){
    $query->where(['p_uid' => 1]);
});

// ... 执行其他逻辑 比如判断上下级 操作权限等等

// 业务需求不只是读取用户的数据这么简单
// 还要扣除余额(就是更新数据库)
$userOneInfo->u_balance = 0;
$userOneRes = $userOneInfo->save();

$userTwoInfo->u_balance = 0;
$userTwoRes =  $userTwoInfo->save();

// ... 执行其他逻辑
```

因为`一个对象映射一条数据`，所以我们在操作同样where条件的数据，直接操作对象就可以了， 就不用反复编写where u\_id =1更新， u\_id = 1 要删除 使用模型，还有很多用处，（得益于开源团队的奉献，为我们封装了大量的功能） 比如： - 用户表新增一条数据，另一个附属表也要用该用户id初始化一行。 - 自动转换数据格式（储存时间戳，查询出来为2019-7-13 19:53:04格式）。 - 自动校验数据，自动完成数据（操作的时候默认取操作人ip 权限等储存）。 - 关联查询（TP中非常强大的功能，在模型中定义好与另一个模型的关系，比如店铺表中的u\_id 可以用来查询出店铺所属用户的信息 相当于店铺模型和用户模型的关联 自动join数据 合并 返回给我们使用） - 等等

## 总结

*   ORM是一种思想，概念，代表 对象-关系映射（数据库-对象 映射）
*   ORM使得对数据的操作抽象为对对象的操作。
*   要学会思想的改变，利用好框架提供的特性，编写更好地代码。
*   TP中的模型非常强大，封装了大量的逻辑。